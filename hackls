<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fake Terminal — Animated</title>
  <style>
    :root{
      --bg:#0b0f14;
      --term:#0f1720;
      --green:#8ef29a;
      --muted:#94a3b8;
      --accent:#7dd3fc;
    }
    html,body{height:100%;margin:0;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;background:linear-gradient(180deg,#071018 0%,#041018 100%);color:var(--muted)}
    .wrap{display:flex;align-items:center;justify-content:center;height:100%;padding:24px;box-sizing:border-box}
    .term {
      width: min(1100px, 96%);
      height: 620px;
      background: linear-gradient(180deg, rgba(8,12,18,1), rgba(6,9,14,1));
      border-radius: 10px;
      box-shadow: 0 10px 40px rgba(2,6,12,0.7);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      border:1px solid rgba(255,255,255,0.03);
    }
    .term-header{
      height:40px; display:flex; align-items:center; gap:12px; padding:8px 12px; background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
    }
    .dots{display:flex; gap:8px}
    .dot{width:12px;height:12px;border-radius:50%}
    .dot.red{background:#ff6b6b}
    .dot.yellow{background:#ffd166}
    .dot.green{background:#2ecc71}
    .title{margin-left:auto;color:var(--muted);font-size:13px}
    .screen{flex:1;padding:14px 18px; overflow:auto; color:var(--green); font-size:14px; line-height:1.45; white-space:pre-wrap}
    .controls{display:flex; gap:8px; padding:12px; align-items:center; background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent)}
    button, select, input[type="range"]{background:transparent;border:1px solid rgba(255,255,255,0.06); color:var(--muted); padding:8px 10px; border-radius:6px; cursor:pointer}
    button.primary{border-color:rgba(125,211,252,0.2); color:var(--accent)}
    .small{font-size:13px; padding:6px 8px}
    .muted{color:var(--muted); font-size:13px}
    .cursor { display:inline-block; width:8px; background:var(--green); margin-left:4px; vertical-align:middle; animation:blink 1s steps(2) infinite;}
    @keyframes blink{50% {opacity:0}}
    /* glow for certain lines */
    .glow { color: #c7f9d6; text-shadow:0 0 8px rgba(142,242,154,0.15) }
    .error { color:#ff8b8b; text-shadow:0 0 6px rgba(255,139,139,0.12) }
    .info { color:var(--accent) }
    .muted-line { color: #7b8892 }
    /* make scroll bar slim */
    .screen::-webkit-scrollbar{width:8px;height:8px}
    .screen::-webkit-scrollbar-thumb{background:rgba(255,255,255,0.04);border-radius:10px}
    .settings { margin-left:8px; display:flex; gap:8px; align-items:center }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="term" role="region" aria-label="Fake terminal">
      <div class="term-header">
        <div class="dots">
          <div class="dot red"></div>
          <div class="dot yellow"></div>
          <div class="dot green"></div>
        </div>
        <div class="title">user@host — fake-terminal</div>
      </div>

      <div id="screen" class="screen" aria-live="polite" tabindex="0"></div>

      <div class="controls">
        <button id="openBtn" class="primary">Open Terminal</button>
        <button id="pauseBtn" class="small">Pause</button>
        <button id="clearBtn" class="small">Clear</button>

        <div class="settings">
          <label class="muted">Speed</label>
          <input id="speed" type="range" min="10" max="150" value="60" />
          <label class="muted">Intensity</label>
          <select id="intensity">
            <option value="low">Low</option>
            <option value="med" selected>Medium</option>
            <option value="high">High</option>
            <option value="spam">Spam</option>
          </select>
        </div>

        <div style="margin-left:auto" class="muted">Tip: Click the terminal to focus and press Pause</div>
      </div>
    </div>
  </div>

  <script>
    /* Fake terminal generator
       - Creates random-looking code, hex, base64, stack traces, "sudo" prompts, fake errors.
       - Types char-by-char and auto-scrolls.
       - Safe: purely visual, no system calls.
    */

    const screen = document.getElementById('screen');
    const openBtn = document.getElementById('openBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const clearBtn = document.getElementById('clearBtn');
    const speedInput = document.getElementById('speed');
    const intensitySelect = document.getElementById('intensity');

    let typing = false;
    let paused = false;
    let queue = [];
    let currentLine = '';
    let cursorVisible = true;
    let typeTimer = null;

    // Templates for different fake outputs
    const templates = {
      js: [
        "function initKernel() {",
        "const token = atob('c2VjcmV0X3Rva2Vu');",
        "for (let i = 0; i < N; i++) { processChunk(i); }",
        "const user = { id: Math.random().toString(36).slice(2), role: 'guest' };",
        "await connect('ws://127.0.0.1:9000');",
        "class Agent { constructor(name){ this.name = name } }",
        "throw new Error('I/O timeout: device did not respond')",
      ],
      bash: [
        "sudo /usr/bin/compile --fast --no-gui",
        "dd if=/dev/zero of=/dev/null bs=1M count=512",
        "echo 'starting diagnostics' && sleep 0.3 && echo done",
        "ps aux | grep -i phantom | grep -v grep || true",
        "iptables -L --line-numbers",
        "tail -f /var/log/syslog | sed -u 's/^/LOG: /'",
      ],
      hex: [
        "0x" + randomHex(32),
        randomHex(16) + ":" + randomHex(8),
        "deadbeef:" + randomHex(12),
      ],
      base64: [
        btoa("session:" + Math.random().toString(36).slice(2)),
        btoa("payload:" + Date.now()),
      ],
      stack: [
        "at com.example.kernel.Driver.handle(Driver.java:142)",
        "at java.base/java.lang.Thread.run(Thread.java:834)",
        "at module.exports (/app/index.js:78:14)",
      ],
      json: [
        JSON.stringify({ status: "ok", id: Math.floor(Math.random()*99999) }),
        JSON.stringify({ error: "timeout", code: 504, retry: true })
      ],
      info: [
        "[INFO] connected to 10.0.0." + randInt(2,254),
        "[INFO] handshake complete",
        "[DBG] memory usage: " + randInt(12,98) + "MB / 2048MB"
      ],
      error: [
        "ERROR: kernel panic - not syncing: Fatal exception",
        "Segmentation fault (core dumped)",
        "Permission denied: cannot access /dev/rdisk0"
      ]
    };

    // Helper functions
    function randInt(a, b) { return Math.floor(Math.random()*(b-a+1)) + a; }
    function randomHex(len){
      const chars = "0123456789abcdef";
      let s = "";
      for(let i=0;i<len;i++) s += chars[Math.floor(Math.random()*chars.length)];
      return s;
    }

    function pick(templateName) {
      const arr = templates[templateName];
      return arr[Math.floor(Math.random()*arr.length)];
    }

    function generateLine(intensity = 'med') {
      // Based on intensity, choose patterns and length
      const options = [];
      if (Math.random() < 0.6) options.push('js');
      if (Math.random() < 0.5) options.push('bash');
      if (Math.random() < 0.4) options.push('info');
      if (Math.random() < 0.35) options.push('hex');
      if (Math.random() < 0.25) options.push('base64');
      if (Math.random() < 0.2) options.push('stack');
      if (Math.random() < 0.15) options.push('error');
      if (Math.random() < 0.12) options.push('json');

      // intensity tweaks
      if (intensity === 'low') options.splice(0, Math.floor(options.length/3));
      if (intensity === 'high') options.push('hex','base64');
      if (intensity === 'spam') options.push('hex','hex','base64','js');

      if (options.length === 0) options.push('info');

      const chunks = [];
      const count = randInt(1, Math.min(4, options.length));
      for (let i=0;i<count;i++) {
        const t = options[Math.floor(Math.random()*options.length)];
        chunks.push(pick(t));
      }

      // randomly wrap code blocks or comments
      let line = chunks.join('  |  ');
      if (Math.random() < 0.12) line = "// " + line;
      if (Math.random() < 0.09) line = "/* " + line + " */";
      if (Math.random() < 0.06) line = line + " // " + randomHex(6);
      return line;
    }

    // Queue system: lines are queued, then typed char-by-char
    function enqueueLines(n = 6) {
      const intensity = intensitySelect.value;
      for (let i=0;i<n;i++) {
        const line = generateLine(intensity);
        queue.push(line);
      }
    }

    function startTyping() {
      if (typing) return;
      typing = true;
      paused = false;
      pauseBtn.textContent = "Pause";
      if (queue.length < 10) enqueueLines(12);
      tick();
    }

    function tick() {
      clearTimeout(typeTimer);
      if (paused) { typing=false; return; }
      if (!currentLine && queue.length === 0) enqueueLines(8);
      if (!currentLine) currentLine = queue.shift() || "";

      const speedVal = parseInt(speedInput.value,10); // lower is faster
      const basedelay = Math.max(8, 160 - speedVal); // in ms
      // adjust per-character delay a bit
      const charDelay = basedelay + randInt(-20, 40);

      // type one char
      const nextChar = currentLine.slice(0,1);
      if (nextChar) {
        appendToScreen(escapeHtml(nextChar), false);
        currentLine = currentLine.slice(1);
        autoScroll();
        typeTimer = setTimeout(tick, charDelay);
      } else {
        // finish line: maybe add newline & occasional fake prompt
        appendToScreen('\\n', true);
        // small pause between lines
        const pauseAfter = randInt(20, 120);
        // occasionally inject a multi-line stack or pause for effect
        if (Math.random() < 0.07) {
          // inject an error block
          appendToScreen(escapeHtml("\n" + pick('error') + "\n"), true, 'error');
        } else if (Math.random() < 0.08) {
          appendToScreen(escapeHtml("\n" + pick('stack') + "\n"), true, 'muted-line');
        }
        currentLine = "";
        if (queue.length < 6) enqueueLines(6 + randInt(0,6));
        typeTimer = setTimeout(tick, pauseAfter);
      }
    }

    function appendToScreen(text, newline=false, cls=null) {
      // find last element or create new
      if (text === '\\n') {
        const br = document.createElement('div');
        br.innerHTML = '<span></span>';
        if (cls) br.classList.add(cls);
        screen.appendChild(br);
      } else {
        // if last child is a div and we are mid-line, append text
        let last = screen.lastElementChild;
        if (!last || last.tagName.toLowerCase() !== 'div') {
          last = document.createElement('div');
          screen.appendChild(last);
        }
        // when adding regular chars to last, we add span
        const span = document.createElement('span');
        if (cls) span.classList.add(cls);
        span.innerHTML = text.replace(/\\n/g,'');
        last.appendChild(span);
      }
    }

    function escapeHtml(s) {
      return s.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
    }

    function autoScroll() {
      screen.scrollTop = screen.scrollHeight;
    }

    // UI actions
    openBtn.addEventListener('click', () => {
      startTyping();
      openBtn.disabled = true;
    });
    pauseBtn.addEventListener('click', () => {
      if (!typing && !paused) { startTyping(); return; }
      paused = !paused;
      if (paused) {
        pauseBtn.textContent = "Resume";
        clearTimeout(typeTimer);
        typing = false;
      } else {
        pauseBtn.textContent = "Pause";
        startTyping();
      }
    });
    clearBtn.addEventListener('click', () => {
      queue = [];
      currentLine = "";
      clearTimeout(typeTimer);
      screen.innerHTML = "";
      typing = false;
      paused = false;
      pauseBtn.textContent = "Pause";
      openBtn.disabled = false;
    });

    // allow clicking the screen to start/pause
    screen.addEventListener('click', () => {
      if (!typing && !paused) startTyping();
      else {
        // toggle pause
        paused = !paused;
        if (paused) { pauseBtn.textContent = "Resume"; clearTimeout(typeTimer); typing=false; }
        else { pauseBtn.textContent = "Pause"; startTyping(); }
      }
    });

    // keyboard shortcuts: Space -> pause/resume, C -> clear
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') { e.preventDefault(); pauseBtn.click(); }
      if (e.key.toLowerCase() === 'c' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); clearBtn.click(); }
    });

    // auto-focus for accessibility
    window.addEventListener('load', () => {
      screen.focus();
      // show a starting header
      screen.innerHTML = '';
      const header = [
        "Fake-Terminal v1.0 — demo output",
        "Booting virtual runtime...",
        "Initializing pseudo-kernel modules...",
        ""
      ];
      header.forEach(h => appendToScreen(escapeHtml(h + "\\n"), true, 'glow'));
      enqueueLines(10);
    });

    // small helper: generate some base64-like values for template building
    function btoa(s) {
      try { return window.btoa(unescape(encodeURIComponent(s))); }
      catch(e){ return window.btoa(s); }
    }
  </script>
</body>
</html>
